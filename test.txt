if(expense.payment_method === "Unpaid" && (server.payment_method === "CASH" || server.payment_method === "IDFC SWATI" || server.payment_method === "IDFC SAM" || server.payment_method === "Net Bank")){
  console.log("UNPAID TO CASH")
  const from = await models.ProductModel.Bank.findOne({ name : payment_method});

  from.amount = Number(from.amount) - Number(server.total_amount);

  await from.save();

  const debitTransactionData = {
    type: payment_method, // You can adjust the type based on your requirements
    from: "Purchase",
    to: `Product -- ${server.name}`,
    transaction_id: uuidv4(), // Assuming bank _id is unique identifier for transaction
    debited: Number(server.total_amount),
    credited: 0.0,
    available: Number(from.amount),
    date: formattedDate
  }; 
  
  const debitTransaction = new models.ProductModel.Transaction(debitTransactionData);
  await debitTransaction.save();
}else if ( server.payment_method !== "Unpaid" && server.payment_method !== product.payment_method) {
  console.log("PAID TO PAID")
  const from = await models.ProductModel.Bank.findOne({ name: server.payment_method});
  const to = await models.ProductModel.Bank.findOne({ name: product.payment_method});

  // Calculate the amount to be transferred
  const amount = Number(server.total_amount);
  console.log(amount)

  // Update the 'from' bank's amount (debit)
  from.amount = Number(from.amount) - amount;
  await from.save();

  // Update the 'to' bank's amount (credit)
  to.amount = Number(to.amount) + amount;
  await to.save();

  // Create a transaction record for debit
  const debitTransactionData = {
      type: from.name, // You can adjust the type based on your requirements
      from: "Purchase",
      to: `Product -- ${server.name}`,
      transaction_id: uuidv4(), // Assuming bank _id is unique identifier for transaction
      debited: amount,
      credited: 0.0,
      available: Number(from.amount),
      date: server.date || formattedDate
  };
  
  console.log(debitTransactionData)
  const debitTransaction = new models.ProductModel.Transaction(debitTransactionData);
  await debitTransaction.save();

  // Create a transaction record for credit
  const creditTransactionData = {
      type: to.name, // You can adjust the type based on your requirements
      from: "Purchase Refund",
      to: `Product -- ${server.name}`,
      transaction_id: uuidv4(), // Assuming bank _id is unique identifier for transaction
      debited: 0.0,
      credited: amount,
      available: Number(to.amount),
      date: server.date || formattedDate
  };
  console.log(creditTransactionData)
  const creditTransaction = new models.ProductModel.Transaction(creditTransactionData);
  await creditTransaction.save();
} else if (server.payment_method === "Unpaid" && (product.payment_method === "CASH" || product.payment_method === "IDFC SWATI" || product.payment_method === "IDFC SAM" || product.payment_method === "Net Bank")) {
  console.log("PAID TO UNPAID")
  const from = await models.ProductModel.Bank.findOne({ name : product.payment_method});

  from.amount = Number(from.amount) + Number(server.total_amount);

  await from.save();

  const debitTransactionData = {
    type: product.payment_method, // You can adjust the type based on your requirements
    from: "Purchase Refund",
    to: `Product -- ${server.name}`,
    transaction_id: uuidv4(), // Assuming bank _id is unique identifier for transaction
    debited: 0.0,
    credited: Number(server.total_amount),
    available: Number(from.amount),
    date: formattedDate
  }; 
  
  const debitTransaction = new models.ProductModel.Transaction(debitTransactionData);
  await debitTransaction.save();
}else{
  console.log("Passed")
}



// 